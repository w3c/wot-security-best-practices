<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link rel="stylesheet" href="tablestyle.css">
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Security Best Practices</title>
    <script class="remove" async="" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove">
          var respecConfig = {
              specStatus:     "ED"
            , noRecTrack:     "true"
            , processVersion: 2017
            , shortName:      "wot-security-best-practices"
            , copyrightStart: 2017
            , wg:             "Web of Things Working Group"
            , wgURI:          "https://www.w3.org/WoT/WG/"
            , wgPublicList:   "public-wot-wg"
            , edDraftURI:     "https://w3c.github.io/wot-security-best-practices/"
            , githubAPI:      "https://api.github.com/repos/w3c/wot-security-best-practices"
            , issueBase:      "https://www.github.com/w3c/wot-security-best-practices/issues"
            , editors: [
                {
                  name:       "Elena Reshetova"
                , w3cid:      "99327"
                , company:    "Intel Corp."
                , companyURL: "https://www.intel.com/"
                },
                {
                  name:       "Michael McCool"
                , w3cid:      "93137"
                , company:    "Intel Corp."
                , companyURL: "https://www.intel.com/"
                }
              ]
            , otherLinks: [
                {
                  key: "Contributors"
                , data: [
                    {
                      value: "In the GitHub repository"
                    , href: "https://github.com/w3c/wot-security-best-practices/graphs/contributors"
                    }
                  ]
                }
              , {
                  key: "Repository",
                  data: [
                    {
                      value: "We are on GitHub",
                      href: "https://github.com/w3c/wot-security-best-practices/"
                    }
                  , {
                      value: "File a bug",
                      href: "https://github.com/w3c/wot-security-best-practices/issues"
                    }
                  , {
                      value: "Contribute",
                      href: "https://github.com/w3c/wot-security-best-practices/pulls"
                    }
                  ]
                }
              ]
            , localBiblio: {
                "CoRE-RD": {
                  href: "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11"
                , title: "CoRE Resource Directory"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "03 July 2017"
                },
                "Ocf17": {
                  href: "https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf"
                , title: "The OCF Security Specification, version 1.0.0"
                , publisher: "OCF"
                , date: "June 2017"
                },
                "JWT15": {
                  href: "https://tools.ietf.org/html/rfc7519"
                , title: "JSON Web Token (JWT)"
                , publisher: "IETF"
                , date: "May 2015"
                },
                "CBOR17": {
                  href: "https://tools.ietf.org/pdf/draft-ietf-ace-cbor-web-token-07.pdf"
                , title: "CBOR Web Token (CWT)"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "June 2017"
                },
                "OSCOAP17": {
                  href: "https://tools.ietf.org/pdf/draft-ietf-core-object-security-04.pdf"
                , title: "Object Security of CoAP (OSCOAP)"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "July 2017"
                },
                "COSE17": {
                  href: "https://tools.ietf.org/pdf/draft-ietf-cose-msg-24.pdf"
                , title: "CBOR Object Signing and Encryption (COSE)"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "May 2017"
                },
                "Bel89": {
                  authors: ["S. Bellovin"]
                , href: "https://cseweb.ucsd.edu/classes/sp99/cse227/ipext.pdf"
                , title: "Security Problems in the TCP-IP Protocol Suite"
                , publisher: "Computer Communication Review, Vol. 19, No. 2" 
                , pages: "32-48"
                , date: "April 1989"
                },
                "Bel13": {
                  authors: ["S. Bellovin"]
	          , href: "https://csrc.nist.gov/csrc/media/events/workshop-on-improving-trust-in-the-online-marketpl/documents/presentations/bellovin_ca-workshop2013.pdf"
                  , title: "Web Security in the Real World" 
                  , publisher: "Workshop on Improving Trust in the Online Marketplace, NIST" 
                  , date: "April 2013"
                },
                "Ber14": {
                  authors: ["V. Bertocci"]
                  , href: "http://www.cloudidentity.com/blog/2014/04/22/authentication-protocols-web-ux-and-web-api/"
                  , title: "Authentication Protocols, Web UX and Web API" 
                  , date: "April 2014"
                },
                "Bor14": {
                  authors: ["C. Bormann", "et al."]
                  , href: "https://tools.ietf.org/rfc/rfc7228.txt"
                  , title: "Terminology for Constrained-Node Networks"
                  , publisher: "IETF RFC 7228"
                  , date: "May 2014"
                },
                "Bru14": {
                  authors: ["C. Brubaker", "et al."]
                  , href: "https://www.cs.utexas.edu/~shmat/shmat_oak14.pdf"
                  , title: "Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations"
                  , publisher: "IEEE Security Privacy"
                  , date: "2014"
                  , pages: "114-129"
                },
                "Coo13": {
                  authors: ["A. Cooper", "et al"]
                  , href: "https://tools.ietf.org/html/rfc6973"
                  , title: "Privacy Considerations for Internet Protocols"
                  , publisher: "IETF RFC 6973 (IAB Guideline)"
                  , date: "July 2013"
                },
                "Lea05": {
                  authors: ["P. Leach", "et al"]
                  , href: "https://tools.ietf.org/html/rfc4122"
                  , title: "A Universally Unique IDentifier (UUID) URN Namespace"
                  , publisher: "IETF RFC 4122"
                  , date: "July 2005"
                },
                "Dur13": {
                  authors: ["Z. Durumeric", "et al."]
                  , href: "https://conferences.sigcomm.org/imc/2013/papers/imc257-durumericAemb.pdf"
                  , title: "Analysis of the HTTPS Certificate Ecosystem"
                  , publisher: "Proc. of the 2013 conference on Internet measurement conference"
                  , date: "October 2013"
                },
                "Ell00": {
                  authors: ["C. Ellison", "B. Schneier"]
                  , href: "https://www.schneier.com/paper-pki.pdf"
                  , title: "Ten Risks of PKI: What You’re not Being Told about Public Key Infrastructure"
                  , publisher: "Computer Security Journal, v 16, n 1,"
                  , date: "2000"
                  , pages: "1-7"
                },
                "Fu01": {
                  authors: ["K. Fu", "et al."]
                  , href: "https://pdos.csail.mit.edu/papers/webauth:sec10.pdf"
                  , title: "Dos and Don’ts of Client Authentication on the Web"
                  , publisher: "Proc. 10th USENIX Security Symposium"
                  , date: "August 2001"
                },
                "Garcia17": {
                  authors: ["O. Garcia-Morchon", "S. Kumar", "M. Sethi"]
                  , title: "State-of-the-Art and Challenges for the Internet of Things Security"
                  , href: "https://datatracker.ietf.org/doc/draft-irtf-t2trg-iot-seccons/"
                },
                "Geo12": {
                  authors: ["M. Georgiev", "et al."]
                  , href: "https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf"
                  , title: "The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software"
                  , publisher: "Proc. of the 2012 ACM conference on Computer and communications security"
                  , date: "2012"
                  , pages: "38-49"
                },
                "Gol03": {
                  authors: ["O. Goldreich"]
                  , href: "http://www.wisdom.weizmann.ac.il/~oded/foc-sur01.html"
                  , title: "Cryptography and Cryptographic Protocols"
                  , publisher: "Distributed Computing, vol. 16"
                  , pages: "177-199"
                  , date: "2003"
                }, 
                "Gre14": {
                  authors: ["M. Green"]
                  , href: "https://blog.cryptographyengineering.com/2014/03/19/how-do-you-know-if-rng-is-working/"
                  , title: "How do you know if an RNG is working?"
                  , date: "March 2014"
                },
                "Gut02": {
                  authors: ["P. Gutman"]
                  , href: "https://www.cs.auckland.ac.nz/~pgut001/pubs/notdead.pdf"
                  , title: "PKI: It’s Not Dead, Just Resting"
                  , publisher: "IEEE Computer, vol. 35, no. 8"
                  , date: "Aug. 2002"
                  , pages: "41-49"
                },
                "Hea13": {
                  authors: ["M. Hearn"]
                  , href: "https://googleblog.blogspot.de/2013/02/an-update-on-our-war-against-account.html"
                  , title: "An update on our war against account hijackers"
                  , date: "Feb 2013"
                },
                "IETFACE": {
                  title: "IETF Authentication and Authorization for Constrained Environments (ACE)"
                  , href: "https://tools.ietf.org/wg/ace/"
                },
                "Iic15": {
                  authors: ["Industrial Internet Consortium"]
                  , href: "http://www.iiconsortium.org/IIRA.htm"
                  , title: "Industrial Internet Reference Architecture"
                  , date: "June 2015"
                },
                "IicRA17": {
                  authors: ["Industrial Internet Consortium"]
                  , href: "https://www.iiconsortium.org/IIRA.htm"
                  , title: "The Industrial Internet of Things Volume G1: Reference Architecture"
                  , publisher: "IIC:PUB:G1:V1.80:20170131"
                  , date: "Jan 2017"
                },
                "IicSF16": {
                  authors: ["Industrial Internet Consortium"]
                  , href: "https://www.iiconsortium.org/IISF.htm"
                  , title: "The Industrial Internet of Things Volume G4: Security Framework"
                  , publisher: "IIC:PUB:G4:V1.0:PB:20160926"
                  , date: "Sept 2016"
                },
                "ISF17": {
                  authors: ["IoT Security Foundation"]
                  , href: "https://iotsecurityfoundation.org/best-practice-guidelines/"
                  , title: "IoT Security Foundation Best Practice Guidelines"
                  , date: "May 2017"
                },
                "Jon14": {
                  authors: ["M. Jones"]
                  , href: "http://www.niso.org/sites/default/files/stories/2017-08/SP_Jones_JSON_isqv26no3.pdf"
                  , title: "A JSON-Based Identity Protocol Suite"
                  , publisher: "Information Standards Quarterly, vol. 26, no. 3"
                  , date: "2014"
                  , pages: "19–22"
                },
                "Ken03": {
                  authors: ["S. Kent", "L. Millet"]
                  , href: "https://www.nap.edu/read/10656/chapter/1"
                  , title: "Who Goes There? Authentication Through the Lens of Privacy"
                  , publisher: "The National Academies Press, Washington D.C."
                  , date: "2003"
                },
                "Lam04": {
                  authors: ["B. Lampson"]
                  , href: "https://pdfs.semanticscholar.org/6fe5/ba7a096e391d985e7818fef9d0f0636210a0.pdf"
                  , title: "Computer Security in the Real World"
                  , publisher: "IEEE Computer, vol. 37, no. 6"
                  , date: "June 2004"
                  , pages: "37-46"
                },
                "Loc05": {
                  authors: ["H. Lockhart"]
                  , href: "http://www.oracle.com/technetwork/testcontent/saml-084342.html"
                  , title: "Demystifying SAML"
                  , date: "May 2005"
                },
                "Mel15": {
                  authors: ["D. Melzer"]
                  , href: "https://c.ymcdn.com/sites/www.issa.org/resource/resmgr/journalpdfs/feature0615.pdf"
                  , title: "Securing the Industrial Internet of Things"
                  , date: "June 2015"
                },
                "Mic17": {
                  authors: ["Microsoft"]
                  , href: "https://docs.microsoft.com/en-us/azure/iot-suite/iot-security-architecture"
                  , title: "Internet of Things security architecture"
                  , publisher: "STRIDE threat model for IoT"
                  , date: "Jan 2017"
                },
                "Moo02": {
                  authors: ["T. Moors"]
                  , href: "https://www.csd.uoc.gr/~hy435/material/moors.pdf"
                  , title: "A critical review of End-to-end arguments in system design"
                  , publisher: "Proc. of the IEEE International Conference on Communications"
                  , date: "2002"
                },
                "Nis15": {
                  authors: ["NIST"] 
                  , title: "Guide to Industrial Control Systems (ICS) Security"
                  , publisher: "NIST Special Publication 800-82"
                },
                "Oos10": {
                  authors: ["M. Oosdijk", "et al."]
                  , href: "https://tnc2011.terena.org/getfile/696"
                  , title: "Provisioning scenarios in identity federations"
                  , publisher: "Surfnet Research Paper" 
                  , date: "2010"
                },
                "Owa17": {
                  authors: ["OWASP"]
                  , href: "https://www.owasp.org/index.php/Threat_Risk_Modeling"
                  , title: "Threat Risk Modeling"
                  , publisher: "OWASP"
                  , date: "Jan 2017"
                },
                "Res03": {
                  authors: ["E. Rescorla", "et al."]
                  , href: "https://tools.ietf.org/html/rfc3552"
                  , title: "Guidelines for Writing RFC Text on Security Considerations"
                  , publisher: "IETF RFC 3552 (IAB Guideline)"
                  , date: "2003"
                },
                "Sch14": {
                  authors: ["B. Schneier"]
                  , href: "https://www.wired.com/2014/01/theres-no-good-way-to-patch-the-internet-of-things-and-thats-a-huge-problem/"
                  , title: "The Internet of Things Is Wildly Insecure — And Often Unpatchable"
                  , publisher: "Wired"
                  , date: "Jan. 2014"
                },
                "Sch99": {
                  authors: ["B. Scheier", "A. Shostack"]
                  , href: "https://www.schneier.com/paper-smart-card-threats.pdf"
                  , title: "Breaking Up Is Hard To Do: Modeling Security Threats for Smart Cards"
                  , publisher: "USENIX Workshop on Smart Card Technology, USENIX Press"
                  , date: "1999"
                  , pages: "175-185"
                },
                "She14": {
                  authors: ["Z. Shelby", "et al."]
                  , href: "https://tools.ietf.org/rfc/rfc7252.txt"
                  , title: "The Constrained Application Protocol (CoAP)"
                  , publisher: "IETF RFC 7252"
                  , date: "June 2014"
                 },
                "Vol00": {
                  authors: ["J. Vollbrecht", "et al."]
                  , href: "https://tools.ietf.org/rfc/rfc2904.txt"
                  , title: "AAA Authorization Framework"
                  , publisher: "IETF RFC 2904"
                  , date: "Aug. 2000"
                },
                "Yeg11": {
                  authors: ["S. Yegge"]
                  , href: "https://plus.google.com/+RipRowan/posts/eVeouesvaVX"
                  , title: "Stevey's Google Platforms Rant"
                  , publisher: "Blog"
                  , date: "Oct. 2011"
                }
              }
            };
    </script>
  </head>
  <body>
    <section id="abstract">
     <p>
     This document provides non-normative guidance on 
     how to implement Web of Things (WoT) using best practices 
     for security and privacy.
     When doing security testing, use of these best practices is assumed.
     </p>
    </section>

    <section id="sotd">
      <p class="ednote" title="The W3C WoT WG is asking for feedback">
        Please contribute to this draft using the 
        <a href="https://github.com/w3c/wot-security-best-practices/issues">GitHub Issue</a> 
        feature of the <a href="https://github.com/w3c/wot-security-best-practices/">WoT 
        Security Best Practices /a> repository.
      </p>
    </section>

    <section>
      <h1>Introduction</h1>
      <p>
        For a general discussion of WoT security and privacy issues, see the  
	<a href="https://www.w3.org/TR/2018/NOTE-wot-security-20181203/">WoT 
        Security and Privacy Guidelines</a> document.
      </p>
      <p>For details on the Web of Things architecture, please refer to the following:
      <ul>
        <li>the <a href="https://www.w3.org/WoT/IG/">Interest Group</a> web site</li>
        <li>the <a href="https://www.w3.org/WoT/WG/">Working Group</a> web site</li>
	<li>the <a href="https://www.w3.org/TR/2017/WD-wot-architecture-20170914/">WoT Architecture</a> 
            document,</li>
        <li>the <a href="https://www.w3.org/TR/2017/WD-wot-thing-description-20170914/">WoT Thing Description</a> 
            document,</li>
        <li>the <a href="https://w3c.github.io/wot-binding-templates/">WoT Binding Templates</a> 
            document, and</li>
        <li>the <a href="https://www.w3.org/TR/2017/WD-wot-scripting-api-20170914/">WoT Scripting API</a> 
            document.</li>
      </ul>
      </p>
    </section>

    <section>
      <h1>Secure Transport</h1>
      <p>In general, the recommendation is to use the latest version of
      TLS and DTLS available, consistent with interoperability requirements.
      Currently, the latest version of TLS is 1.3 but as this is not yet
      widely deployed, for interoperability a system may have to be based on 
      TLS 1.2.  
      However, as TLS 1.3 addresses several vulnerabilities in TLS 1.2 
      in general a migration plan should be in place to TLS 1.3 and new
      implementations should target TLS 1.3 if possible.
      </p>
      <p>Ideally systems would implement the following for each of the given protocols:
      <dl>
        <dt>HTTPS:</dt><dd><p>HTTP + TLS 1.3</p></dd> 
        <dt>CoAPS:</dt><dd><p>CoAP + DTLS.  See also:
        <ul>
          <li><a href="https://tools.ietf.org/html/rfc7925">IETF RFC7925:</a> 
                  Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS)
                  Profiles for the Internet of Things</li>
          <li><a href="https://tools.ietf.org/html/rfc7252">IETF RFC7252:</a>
                  The Constrained Application Protocol (CoAP)</li>
        </ul></p></dd>
        <dt>MQTTS:</dt><dd><p>MQTT + TLS 1.3.  See also:
        <ul>
          <li><a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt">
            OASIS Message Queuing Telemetry Transport (MQTT) TC</a></li>
          <li><a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt-security">
            MQTT Security Subcommittee</a></li> 
          <li>Standard URL scheme for "mqtts://..." 
              (Note: a draft IETF RFC for the MQTT URL scheme is being discussed)</li>
        </ul></p></dd>
      </dl>
    </section>

    <section>
      <h1>Authentication and Access Control</h1>
      <p>
      The best practices for authentication and access control depend on the protocol.
      In most cases, authentication schemes should only be considered 
      secure when used in combination with secure transport.
      We recommend the following combinations:
      <ul>
      <li>HTTPS with one of oauth2, bearer, basic, or digest security schemes.</li>
      <li>CoAPS with one of psk, public, or cert security schemes.</li>
      <li>MQTTS with basic AND psk (MQTT native username/password with psk for encrypted communication)</li>
      </ul>
      </p>
      <p>In addition, TDs with HTTP/nosec and CoAP/nosec should be tested and properly handled.
      They are useful in conjunction with proxies that layer on one of the above secure
      transport and authentication schemes.
      </p>
      <p>"Local HTTPS" is still a topic of discussion.  In addition to the above schemes,
      using HTTPS with psk, public, or cert schemes to share keys to be used for TLS transport
      is also acceptable for machine-to-machine communication.  However, currently such schemes may
      require the user to manually install or accept keys or certificates when using a browser.
      </p>

      <section id="oauth-flows">
        <h2>OAuth2 Flows</h2>
        <dl>
          <dt>Motivation</dt>
          <dd>

            OAuth 2.0 is an authorization protocol widely known for its usage across several web services.
            It enables third-party applications to obtain limited access to HTTP services on behalf of the resource
            owner
            or of itself.
            The protocol defines the following actors:

            <ul>
              <li>Client: an application that wants to use a resource owned by the resource owner. </li>
              <li>Authorization Server: An intermediary that authorizes the client for a particular `scope`. </li>
              <li>Resource: a web resource </li>
              <li>Resource Server: the server where the resource is stored</li>
              <li>Resource Owner: the owner of a particular web resource. If it is a human is usually referred to as an
                end-user. More specifically from the RFC:</li>
              <ul>
                <li>An entity capable of granting access to a protected resource.</li>
              </ul>
            </ul>

            These actors can be mapped to WoT entities:
            <ul>
              <li>Client is a WoT Consumer</li>
              <li>Authorization Server is a third-party service</li>
              <li>Resource is an interaction affordance</li>
              <li>Resource Server is a Thing described by a Thing Description acting as a server. </li>
              May be a device or a service.
              <li>Resource Owner might be different in each use case.
                A Thing Description may also combine resources from different owners or web server.</li>
            </ul>
            TO DO: Check the OAuth 2.0 spec to determine exactly how Resource Owner is defined.
            Is it the actual owner of the resource (eg running the web server) or simply someone
            with the rights to access that resource?
            <br>
            The OAuth 2.0 protocol specifies an authorization layer that separates the client from the resource owner.
            The basic steps of this protocol are summarized in the following diagram:
            <pre>
     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&gt;| Authorization |
     | Client |                               |     Server    |
     |        |&lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&gt;|    Resource   |
     |        |                               |     Server    |
     |        |&lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
</pre>
            Steps A and B defines what is known as authorization grant type or flow.
            What is important to realize here is that not all of these interactions
            are meant to take place over a network protocol.
            In some cases,
            interaction with with a human through a user interface may be intended.

            OAuth2.0 defines 4 basic flows plus an extension mechanism.
            The most common of which are:
            <ul>
              <li>`code`</li>
              <li>`implicit`</li>
              <li>`password` (of resource owner)</li>
              <li>`client` (credentials of the client)</li>
            </ul>

            In addition, a particular extension which is of interest to IoT is the `device` flow.

            Further information about the OAuth 2.0 protocol can be found in
            <a href="https://tools.ietf.org/html/rfc6749#section-1">IETF RFC6749</a>.
            In addition to the flows, OAuth 2.0 also supports scopes.
            Scopes are identifiers which can be attached to tokens.
            These can be used to limit authorizations to
            particular roles or actions in an API.
            Each token carries a set of scopes and these can be checked when an interaction
            is attempted and access can be denied if the token does not include a scope
            required by the interaction.

            This document describes relevant use cases for each of the OAuth 2.0 authorization flows.

          </dd>
          <dt>Expected Devices</dt>
          <dd>

            To support OAuth 2.0, all devices must have the capability of:
            <ul>
              <li>Both the producer and consumer must be able to create and participate in a TLS connection.</li>
              <li>The producer must be able to verify an access (bearer) token (i.e. have sufficient computational
                power/connectivity). </li>
            </ul>

            Comment:
            <ul>
              <li>Investigate whether DTLS can be used.</li>
              Certainly the connection needs to be encrypted; this is required in the OAuth 2.0 specification.
              <li>Investigate whether protocols other than HTTP can be used, e.g. CoAP.</li>
              <ul>
                <li>found an interesting IETF draft RFC about CoAP support(encrypted using various mechanisms like DTLS
                  or
                  CBOR Object Signing and Encryption): <a
                    href="https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-35">draft-ietf-ace-oauth</a></li>
              </ul>
            </ul>

          </dd>
          <dt>Expected Data</dt>
          <dd>

            Depending on the OAuth 2.0 flow specified, various URLs and elements need to be specified,
            for example, the location of an authorization token server.
            OAuth 2.0 is also based on bearer tokens and so
            needs to include the same data as those, for example, expected encryption suite.
            Finally,
            OAuth 2.0 supports scopes so these need to be defined in the security scheme and specified in
            the form.

          </dd>
          <dt>Affected WoT deliverables and/or work items</dt>
          <dd>

            Thing Description, Scripting API, Discovery, and Security.

          </dd>
          <dt>Description</dt>
          <dd>

            A general use case for OAuth 2.0 is when a WoT consumer wants to access restricted interaction
            affordances.
            In particular, when those affordances have a specific resource owner which
            may grant some temporary permissions to the consumer.

            The WoT consumer can either be hosted in a remote device or interact directly with the end-user inside an
            application.

          </dd>
          <dt>Variants</dt>
          <dd>

            For each OAuth 2.0 flow, there is a corresponding use case variant.
            We also include the experimental "device" flow for consideration.

            <br>
            <br>
            code

            A natural application of this protocol is when the end-user wants to interact directly with the consumed
            thing or to grant his authorization to a remote device. In fact from the <a
              href="https://tools.ietf.org/html/rfc6749#section-4.1">RFC6749</a>

            <ul>
              <li>
                Since this is a redirection-based flow, the client must be capable of
                interacting with the resource owner's user-agent (typically a web
                browser) and capable of receiving incoming requests (via redirection)
                from the authorization server.
              </li>
            </ul>

            This implies that the code flow can be only used when the resource owner interacts directly with the WoT
            consumer at least once. Typical scenarios are:

            <ul>
              <li>In a home automation context, a device owner uses a third party software to interact
                with/orchestrate one or more devices</li>
              <li>Similarly, in a smart farm, the device owner might delegate its authorization to third party
                services.</li>
              <li>In a smart home scenario, Thing Description Directories might be deployed using this authorization
                mechanism. In particular, the list of the registered TDs might require an explicit read authorization
                request to the device owner (i.e. an human who has bought the device and installed it). </li>
              <li>... </li>
            </ul>

            The following diagram shows the steps of the protocol adapted to WoT idioms and entities. In this
            scenario, the WoT Consumer has read the Thing Description of a Remote Device and want to access one of its
            WoT Affordances protected with OAuth 2.0 code flow.
            <pre>
                                                 +-----------+
  +----------+                                   |           |
  | Resource |                                   |  Remote   |
  |   Owner  |                                   |  Device   +&lt;-------+
  |          |                                   |           |        |
  +----+-----+                                   +-----------+        |
       ^                                                              |
       |                                                              |
      (B)                                                             |
+------------+          Client Identifier      +---------------+      |
|           ------(A)-- & Redirection URI ----&gt;+               |      |
|   User-    |                                 | Authorization |      |
|   Agent   ------(B)-- User authenticates ---&gt;+     Server    |      |
|            |                                 |               |      |
|           ------(C)-- Authorization Code ---&lt;+               |      |
+---+----+---+                                 +---+------+----+      |
    |    |                                         ^      v           |
   (A)  (C)                                        |      |           |
    |    |                                         |      |           |
    ^    v                                         |      |           |
+---+----+---+                                     |      |           |
|            |&gt;-+(D)-- Authorization Code ---------'      |           |
|    WoT     |         & Redirection URI                  |           |
|  Consumer  |                                            |           |
|            |&lt;-+(E)----- Access Token -------------------'           |
+-----+------+      (w/ Optional Refresh Token)                       |
      v                                                               |
      |                                                               |
      +-----------(F)----- Access WoT --------------------------------+
                           Affordance
</pre>
            Notice that steps (A), (B) and (C) are broken in two parts as they pass through the User-Agent.

            <p>device</p>

            The device flow (IETF <a href="https://tools.ietf.org/html/rfc8628">RFC 8628</a>) is a variant of the code
            flow for browserless and
            input-constrained devices. Similarly, to its <i>parent</i> flow, it requires a close interaction between the
            resource owner and the WoT consumer. Therefore, the use cases for this flow are the same as the code
            authorization grant but restricted to all devices that do not have a rich means to interact with the
            resource owner. However, differently from `code`, RFC 8628 states explicitly that one of the actors of
            the protocol is an <b>end-user</b> interacting with a <b>browser</b> (even if <a
              href="https://tools.ietf.org/html/rfc8628#section-6.2">section-6.2</a>
            briefly describes an authentication using a companion app and BLE), as shown in the following (slightly
            adapted) diagram:

            <pre>
+----------+
|          |
|  Remote  |
|  Device  |
|          |
+----^-----+
     |
     | (G) Access WoT Affordance
     |
+----+-----+                                +----------------+
|          +&gt;---(A)-- Client Identifier ---v+                |
|          |                                |                |
|          +&lt;---(B)-- Device Code,      ---&lt;+                |
|          |          User Code,            |                |
|   WoT    |          & Verification URI    |                |
| Consumer |                                |                |
|          |  [polling]                     |                |
|          +&gt;---(E)-- Device Code       ---&gt;+                |
|          |          & Client Identifier   |                |
|          |                                |  Authorization |
|          +&lt;---(F)-- Access Token      ---&lt;+     Server     |
+-----+----+   (& Optional Refresh Token)   |                |
      v                                     |                |
      :                                     |                |
     (C) User Code & Verification URI       |                |
      :                                     |                |
      ^                                     |                |
+-----+----+                                |                |
| End User |                                |                |
|    at    +&lt;---(D)-- End user reviews  ---&gt;+                |
|  Browser |          authorization request |                |
+----------+                                +----------------+
</pre>
            Notable mentions:
            <ul>
              <li>the protocol is heavily end-user oriented. In fact, the RFC states the following</li>
              <ul>
                <li>Due to the polling nature of this protocol (as specified in Section 3.4), care is needed to avoid
                  overloading the capacity of the token endpoint. To avoid unneeded requests on the token endpoint, the
                  client SHOULD only commence a device authorization request when <b>prompted by the user and not
                    automatically</b>, such as when the app starts or when the previous authorization session expires or
                  failAs.</li>
              </ul>
              <li>TLS is required both between WoT Consumer/Authorization Server and between Browser/Authorization
                Server</li>
              <li>Other user interactions methods may be used but are left out of scope</li>
            </ul>

            <p>client credential</p>

            The Client Credentials grant type is used by clients to obtain an access token outside of the context of
            an end-user. From <a href="https://tools.ietf.org/html/rfc6749#section-4.4">RFC6749</a>:

            <ul>
              <li>The client can request an access token using only its client
                credentials (or other supported means of authentication) when
                the client is requesting access to the protected resources under its
                control, or <b>those of another resource owner that has been previously
                  arranged with the authorization server</b> (the method of which is beyond
                the scope of this specification).</li>
            </ul>

            Therefore the client credential grant can be used:
            <ul>
              <li>When the resource owner is a public authority. For example, in a smart city context, the authority
                provides a web service where to register an application id.</li>
              <li>Companion application</li>
              <li>Industrial IoT. Consider a smart factory where the devices or services are provisioned with client
                credentials. </li>
              <li>...</li>
            </ul>

            The Client Credentials flow is illustrated in the following diagram. Notice how the Resource Owner is not
            present.

            <pre>
+----------+
|          |
|  Remote  |
|  Device  |
|          |
+----^-----+
     |
     |  (C) Access WoT Affordance
     ^
+----+-----+                                  +---------------+
|          |                                  |               |
|          +&gt;--(A)- Client Authentication ---&gt;+ Authorization |
|   WoT    |                                  |     Server    |
| Consumer +&lt;--(B)---- Access Token ---------&lt;+               |
|          |                                  |               |
|          |                                  +---------------+
+----------+
</pre>
            Comment: Usually client credentials are distributed using an external service which is used by humans to
            register a particular application. For example, the `npm` cli has a companion dashboard where a developer
            requests the generation of a token that is then passed to the cli. The token is used to verify the
            publishing process of `npm` packages in the registry. Further examples are Docker cli and OpenId Connect
            Client Credentials.

            <p>implicit</p>
            <b>Deprecated</b>
            From <a href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1.2">OAuth 2.0
              Security Best Current Practice</a>:
            <ul>
              <li>
                In order to avoid these issues, clients SHOULD NOT use the implicit
                grant (response type "token") or other response types issuing access
                tokens in the authorization response, unless access token injection
                in the authorization, response is prevented and the aforementioned
                token leakage vectors are mitigated.
              </li>
            </ul>

            The RFC above suggests using `code` flow with Proof Key for Code Exchange (PKCE) instead.
            <br>
            The implicit flow was designed for public clients typically implemented inside a browser (i.e. javascript
            clients). As the `code` is a redirection-based flow and it requires direct interaction with the resource's
            owner user-agent. However, it requires one less step to obtain a token as it is returned directly in the
            authentication request (see the diagram below).
            <br>
            Considering the WoT context this flow is not particularly different from `code` grant and it can be used
            in the same scenarios.
            <br>
            Comment: even if the `implicit` flow is deprecated existing services may still using it.

            <pre>
+----------+
| Resource |
|  Owner   |
|          |
+----+-----+
     ^
     |
    (B)
+----------+          Client Identifier     +---------------+
|         ------(A)-- & Redirection URI ---&gt;+               |
|  User-   |                                | Authorization |
|  Agent  ------(B)-- User authenticates --&gt;+     Server    |
|          |                                |               |
|          +&lt;---(C)--- Redirection URI ----&lt;+               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          +----(D)--- Redirection URI ----&gt;+   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  +&lt;---(E)------- Script ---------&lt;+               |
|          |                                +---------------+
+-+----+---+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+-+----+---+                                   +----------+
|          |                                   |  Remote  |
|   WoT    +&gt;---------(H)--Access WoT---------&gt;+  Device  |
| Consumer |               Affordance          |          |
|          |                                   +----------+
+----------+

</pre>

            <p>resource owner password</p>
            <b>Deprecated</b> From <a
              href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1.2">OAuth 2.0 Security
              Best Current Practice</a>:
            <ul>
              <li>The resource owner password credentials grant MUST NOT be used. This
                grant type insecurely exposes the credentials of the resource owner
                to the client. Even if the client is benign, this results in an
                increased attack surface (credentials can leak in more places than
                just the AS) and users are trained to enter their credentials in
                places other than the AS.</li>
            </ul>

            For completeness the diagram flow is reported below.

            <pre>
 +----------+
 | Resource |
 |  Owner   |
 |          |
 +----+-----+
      v
      |    Resource Owner
     (A) Password Credentials
      |
      v
+-----+----+                                  +---------------+
|          +&gt;--(B)---- Resource Owner -------&gt;+               |
|          |         Password Credentials     | Authorization |
|   WoT    |                                  |     Server    |
| Consumer +&lt;--(C)---- Access Token ---------&lt;+               |
|          |    (w/ Optional Refresh Token)   |               |
+-----+----+                                  +---------------+
      |
      | (D) Access WoT Affordance
      |
 +----v-----+
 |  Remote  |
 |  Device  |
 |          |
 +----------+
</pre>

          </dd>
          <dt>Security Considerations</dt>
          <dd>

            See OAuth 2.0 security considerations in <a
              href="https://tools.ietf.org/html/rfc6749#section-10">RFC6749</a>.
            See also <a href="https://tools.ietf.org/html/rfc8628#section-5">RFC 8628 section 5</a> for `device` flow.

          </dd>
          <!--dt>Privacy Considerations</dt>
          <dd>
            <section id="todo--privacy-x" class="ednote">TODO:
              Describe any issues related to privacy; if there are none, say "none" and justify
            </section>

          </dd>
          <dt>Gaps</dt>
          <dd>

            <section id="todo-gaps-x" class="ednote" TODO:>TODO: Describe any gaps that are
              not addressed in the current WoT standards and building blocks

          </dd>
          <dt>Existing standards</dt>
          <dd>

            <section id="todo-references-x" class="ednote" TODO:>TODO: Provide links to relevant standards that are
              relevant for this use case</section>

          </dd-->
          <dt>Comments</dt>
          <dd>
            Notice that the OAuth 2.0 protocol is not an authentication protocol, however <a
              href="https://openid.net/connect/">OpenID</a> defines an authentication layer on top of OAuth 2.0.
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h1>Thing Directories</h1>
      <p>Directory services are often used in WoT systems to store TDs and provide discovery
      services.  This is especially useful for devices that need to sleep to conserve battery
      life.  Rather than watching for and responding to discovery requests themselves, they
      can register their TDs with a directory service which can then respond on their behalf.
      Directories can either run locally on a gateway (behind a firewall, on the same
      local network as the devices) or in the cloud (with globally visible URLs).  The security
      considerations and discovery mechanisms are a little different for these two cases.
      Unfortunately directory services have not (yet) been standardized so our recommendations 
      here are general.
      </p>
      <p>A globally accessible directory service will act much like other 
      web services.  It will be available at a "well-known" URL that will have to be configured
      by the user.  Registration of devices will have to be associated with a particular user
      and use of the service will have to be protected by authentication and confidentiality
      mechanisms, such as HTTPS combined with one of the authentication mechanisms listed above.
      The directory service should avoid doing any processing for unauthenticated
      connection attempts in order to protect itself from DoS attacks.
      </p>
      <p>Local directory services may also offer a web interface but may also advertise their
      availability using mDNS/Zeroconf.  Authentication and confidentiality for a local service
      can also be secured via HTTPS although the issues of "local HTTPS" also arise for such
      services; in general, the user may have to "on-board" devices using some kind of 
      pairing approach.  If the local service is located on a network located behind a firewall
      it is possible to depend on link-layer encryption such as WPA2 although this is not
      as secure as transport-layer security using TLS.
      </p><p>
      Registering a device's TD with a directory service is also a suitable time to
      capture user consent for the distribution of the TD and the data from the device.
      Such consent should include appropriate limits on who can access the data and for 
      how long it can be retained.
      Also, since personally-identifiable information can be inferred from TDs,
      TDs should themselves be treated as personally-identifiable information and suitably
      protected.  This means that directories should generally only provide TDs via
      mutually-authenticated channels to users that are authorized to access those TDs.
      </p>
    </section>

    <section>
      <h1>Object Security</h1>
      <p>Object security is recommended if a CoAP or MQTT to HTTP gateway is used that 
      translates protocols.  
      Ideally however you would NOT translate the payload itself but use end-to-end security.
      It is also important to still use object security with TLS and DTLS; object security alone
      is generally insufficient.
      The main advantage of object security is that a compromised Gateway will be 
      prevented from modifying payloads.  
      </p><p>
      Example object-security standards to consider are COSE, OSCORE, and OSCOAP. 
      </p>
   </section>

    <section>
      <h1>Secure Update and Post Manufacturing Provisioning</h1>
      <p>The WoT is primarily concerned with the operational phase of devices.
      It is assumed that devices and other components of a WoT system (gateways, for example)
      start the operational phase in a secure state.  WoT best practices are focused
      on keeping devices and services in a secure state staring from this assumption.
      However, to enter operational state in secure fashion, additional best practices
      need to be followed during manufacturing, deployment and provisioning, and best
      practices should also be followed for secure update.
      </p><p>
      Good references for best practices for secure update and provisioning
      are the IIC Security Framework [[IICSF]] and the IoT Security Foundation's
      guidelines [[IoTSF]].
      </p>
   </section>

    <section>
      <h1>Terminology</h1>
      <p>
        Please refer to the 
	<a href="https://www.w3.org/TR/2017/WD-wot-architecture-20170914/#terminology">WoT Architecture</a> 
	document for terminology definitions.
      </p>
    </section>

    <section>
      <h1>Summary</h1>
    </section>
    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>Cristiano Aguzzi</p>
    </section>

    <!--<section class="appendix remove">
      <h2>Change History</h2>
      <p> @TODO decide whether needed... </p>
    </section>-->
    <script  id="dstimer"  language="javascript">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
    </script>
  </body>
</html>
